1448. Count Good Nodes in Binary Tree
code:
// *
//  * Definition for a binary tree node.
//  * public class TreeNode {
//  *     int val;
//  *     TreeNode left;
//  *     TreeNode right;
//  *     TreeNode() {}
//  *     TreeNode(int val) { this.val = val; }
//  *     TreeNode(int val, TreeNode left, TreeNode right) {
//  *         this.val = val;
//  *         this.left = left;
//  *         this.right = right;
//  *     }
//  * }

class Solution {
    public int tree_trav(TreeNode root, int high, int cou){
        if(root!=null&&root.val>=high){
            cou++;
            high=root.val;
        }
        System.out.println(cou);
        if(root!=null&&root.left==null&&root.right==null)
            return cou;
        if(root!=null&&root.left!=null){
            cou=tree_trav(root.left,high,cou);
        }
        if(root!=null&&root.right!=null){
            cou=tree_trav(root.right,high,cou);
        }
        return cou;
    }
    public int goodNodes(TreeNode root) {
        int cou=1;
        int high = root.val;
        cou=tree_trav(root.left,high,cou);

        cou=tree_trav(root.right,high,cou);
        
        return cou;
    }
    
}

-------------------------------------------------------------------------------


19. Remove Nth Node From End of List
code:
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head.next==null)
            return null;
        ListNode fn,mn;
        int cou=0;
        int tem;
        fn = head;
        mn=head;
        while(fn!=null){
            fn=fn.next;
            cou++;
        }
        tem = cou-n;
        for(int i=0;i<tem-1;i++){
            mn=mn.next;
        }
        if(mn==head&&tem==0){
            head=head.next;
        }
        
        mn.next=mn.next.next;
        

        
        return head;
        
    }
}


-------------------------------------------------------------------------------------------------------------

1. Two Sum
code:
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int []arr;
        arr = new int[2];
        for(int i=0;i<nums.length;i++){
            for(int j=i+1;j<nums.length;j++){
                if(nums[i]+nums[j]==target){
                    arr[0] = i;
                    arr[1] = j;
                    // System.out.println(nums[i]+nums[j]);
                }
            }
        }
        return arr;
    }
}


9. Palindrome Number
code:
class Solution {
    public boolean isPalindrome(int x) {
        int y = x;
        int temp = 0;
        if(x<0)
            return false;
        while(y>0){
            temp = (temp*10)+ y%10;
            y/=10;
        }
        if(temp==x)
            return true;
        else
            return false;
    }
}


21. Merge Two Sorted Lists
code:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummynode = new ListNode;
        ListNode* l1p = list1;
        ListNode* l2p = list2;
        ListNode* p3 = dummynode;
        if(l1p==NULL)
            return l2p;
        else if(l2p==NULL)
            return l1p;
        while(l1p != NULL && l2p != NULL){
            if(l1p->val<=l2p->val){
                p3->next = l1p;
                l1p = l1p->next;
            }
            else{
                p3->next = l2p;
                l2p = l2p->next;
            }
            p3 = p3->next;
        }
        while(l1p!=NULL){
            p3->next = l1p;
            l1p = l1p->next;
            p3 = p3->next;
        }
        while(l2p!=NULL){
            p3->next = l2p;
            l2p = l2p->next;
            p3 = p3->next;
        }
        return dummynode->next;
    }
};


35. Search Insert Position
code:
class Solution {
    public int searchInsert(int[] nums, int target) {
        int j=nums.length;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==target){
                j=i;
                return j;
            }
            else if(nums[i]>target){
                j=i;
                return j;
            }
        }
        return j;
    }
}


94. Binary Tree Inorder Traversal
code:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void help(TreeNode* root,vector<int> &vec){
        if(root==NULL)
            return ;
        help(root->left,vec);
        vec.push_back(root->val);
        help(root->right,vec);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> vec;
        help(root,vec);
        
        return vec;
    }
};


100. Same Tree
code:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        return (p != null && q != null) && (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        
    }
}


101. Symmetric Tree
code:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */


class Solution {
    public boolean flag = true;
    public void check_tree(TreeNode lef,TreeNode rig){
        if(lef!=null && rig==null)
            flag = false;
        if(rig!=null && lef==null)
            flag = false;
        if(lef==null || rig==null)
            return;
        if(lef.val!=rig.val)
            flag = false;
        check_tree(lef.left,rig.right);
        check_tree(lef.right,rig.left);
    }
    public boolean isSymmetric(TreeNode root) {
        check_tree(root.left,root.right);
        return flag;
    }
}


104. Maximum Depth of Binary Tree
code:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==NULL){
            return 0;
        }
        return 1+max(maxDepth(root->left),maxDepth(root->right));
    }
};


112. Path Sum
code:
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if root is None:
            return None
        else:
            if(root.left is None and root.right is None):
                if targetSum - root.val == 0:
                    return True
            return self.hasPathSum(root.left, targetSum-root.val) or self.hasPathSum(root.right, targetSum-root.val)
           
        
        
        
in java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean flag = false;
    public int sum=0;
    public void trav(TreeNode r, int tar){
        if(r==null)
            return;
        sum+=r.val;
        if(sum==tar && r.left==null && r.right==null){
            flag = true;
            return;
        }
        trav(r.left,tar);
        trav(r.right,tar);
        sum-=r.val;
            
    }
    public boolean hasPathSum(TreeNode root, int targetSum) {
        trav(root,targetSum);
        return flag;
    }
}


141. Linked List Cycle
code:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* curr = head;
        ListNode* prev;
        ListNode* dummy = new ListNode;
        while(curr!=NULL && curr->next!=NULL){
            prev = curr;
            curr= curr->next;
            prev->next = dummy;
            if(curr->next==dummy)
                return true;
        }
        return false;
    }
};



144. Binary Tree Preorder Traversal
code:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void rec(TreeNode* root,vector<int> &vec){
        if(root==NULL){
            return ;
        }
        vec.push_back(root->val);
        rec(root->left,vec);
        rec(root->right,vec);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> vec;
        rec(root,vec);
        return vec;
    }
};



206. Reverse Linked List
code:
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        ListNode next;
        while(curr!=null){
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
}



226. Invert Binary Tree
code:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        TreeNode* temp = new TreeNode;
        if(root==NULL)
            return NULL;
        temp = root->right;
        root->right = root->left;
        root->left = temp;
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};


234. Palindrome Linked List
code:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* chk = head;
        ListNode* s = head;
        ListNode* f = head;
        while(f->next!=NULL && f->next->next!=NULL){
            s=s->next;
            f=f->next->next;
        }
        ListNode* prev = NULL;
        ListNode* curr = s->next;
        ListNode* next;
        while(curr!=NULL){
            next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        while(prev!=NULL){
            if(prev->val!=chk->val)
                return false;
            prev=prev->next;
            chk=chk->next;
        }
        return true;
    }
};


617. Merge Two Binary Trees
code:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 ==  null)
            return root2;
        if(root2 == null)
            return root1;
        TreeNode node = new TreeNode(root1.val+root2.val);
        node.left = mergeTrees(root1.left,root2.left);
        node.right = mergeTrees(root1.right,root2.right);
        
        
        return node;
    }
}


872. Leaf-Similar Trees
code:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
import java.util.*;
class Solution {
    public Vector<Integer> tr1 = new Vector<>();
    public Vector<Integer> tr2 = new Vector<>();
    public void rect1(TreeNode root){
        if(root == null)
            return;
        if(root.left==null && root.right==null){
            tr1.add(root.val);
        }
        rect1(root.left);
        rect1(root.right);
    }
    public void rect2(TreeNode root){
        if(root == null)
            return;
        if(root.left==null && root.right==null){
            tr2.add(root.val);
        }
        rect2(root.left);
        rect2(root.right);
    }
    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        rect1(root1);
        rect2(root2);
        if(tr1.size()!=tr2.size())
            return false;
        for(int i=0;i<tr1.size();i++){
            if(tr1.get(i)!=tr2.get(i))
                return false;
        }
        return true;
    }
}


876. Middle of the Linked List
code:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* s = head;
        ListNode* f = head;
        while(f!=NULL && f->next!=NULL){
            f=f->next;
            f=f->next;
            s=s->next;
        }
        return s;
    }
};



658. Find K Closest Elements
in this solution i iterated the whole array once and pushed the absolute difference between each array elements and the value x in a list, and sorted the list 
so the smaller/least difference will the in the starting, and then the list is iterated till k th element and checked for each element in the array which element
has absolute(element-x) in the list. As the array is sorted the this condition |a - x| == |b - x| and a < b will be valid as the least elements will only be
considered.

code:

import java.lang.Math;

class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        List<Integer> l2 = new ArrayList<Integer>();
        List<Integer> l1 = new ArrayList<Integer>();
        for(int i=0;i<arr.length;i++){
            l1.add(Math.abs(arr[i]-x));
        }
        Collections.sort(l1);
        System.out.println(l1);
        for(int i=0;i<k;i++){
            for(int j=0;j<arr.length;j++){
                if(arr[j]!=2147483647&&Math.abs(arr[j]-x)==l1.get(i)){
                    l2.add(arr[j]);
                    arr[j] = 2147483647;
                    break;
                }
            }
            
        }
        System.out.println(l2);
        Collections.sort(l2);
        return l2;
    }
}



2. Add Two Numbers
in this solution i added one - one node of each linked list and pushed it to a list. in the question its given that the value of a node is 0 <= Node.val <= 9
so at most the sum will be 19(carry added) so i took the last digit of the sum and pushed it in the list and set the carry to 1 so in the next iteration the carry 1
will be added to the sum value.
code:
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode newlist = new ListNode();
        ListNode n1 = l1,n2=l2,newl=newlist;
        List<Integer> alist = new ArrayList<Integer>();
        int valst=0,car=-1;
        while(n1!=null||n2!=null){
            // System.out.println(1);
            if(n1!=null&&n2!=null){
                valst=0;
                if(car>0){
                    car=-1;
                    valst++;
                }
                valst = valst + n1.val+n2.val;
            }
            else if(n1!=null&&n2==null){
                valst = 0;
                if(car>0){
                    car=-1;
                    valst++;
                }
                valst = valst + n1.val;
            }
            else if(n1==null&&n2!=null){
                valst = 0;
                if(car>0){
                    car=-1;
                    valst++;
                }
                valst = valst +n2.val;
            }
            
//             if(n1!=null&&n2!=null){
//                 newl.next = new ListNode();
//             }
            
            if(valst>9){
                alist.add(valst%10);
                // newl.val = valst%10;
                car=1;
            }
            else{
                alist.add(valst);
                // newl.val = valst;
            }
            if(n1!=null)
                n1=n1.next;
            if(n2!=null)
                n2=n2.next;
        }
        if(car==1){
            alist.add(1);
        }
        System.out.println(alist);
        for(int i=0;i<alist.size();i++){
            newl.val = alist.get(i);
            if(i!=alist.size()-1){
            newl.next = new ListNode();
            newl=newl.next;
            }
        }
        
        return newlist;
    }
}


new version of code with lesser runtime:

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode n1 = l1,n2 = l2;
        ListNode newlist = new ListNode();
        ListNode nl = newlist;
        nl.val = -9;
        int carry = 0;
        
        while(n1!=null||n2!=null){
            if(n1!=null&&n2!=null){
                nl.val = (n1.val+n2.val+carry)%10;
                carry = (n1.val+n2.val+carry)/10;
            }
            else if(n1!=null&&n2==null){
                nl.val = (n1.val+carry)%10;
                carry = (n1.val+carry)/10;
            }
            else if(n1==null&&n2!=null){
                nl.val = (n2.val+carry)%10;
                carry = (n2.val+carry)/10; 
            }
            if(n1!=null)
                n1=n1.next;
            if(n2!=null)
                n2=n2.next;
            if(n1!=null||n2!=null){
                nl.next = new ListNode(-9);
                nl = nl.next;
            }
            if(n1==null&&n2==null&&carry>0&&nl.next==null){
                nl.next = new ListNode(-9);
                nl = nl.next;
                nl.val = carry;
            }
        }
        
        
        
        return newlist;
    }
}



13. Roman to Integer
code:
class Solution {
    public int romanToInt(String s) {
        int val=0;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='I'&&i!=s.length()-1&&(s.charAt(i+1)=='V'||s.charAt(i+1)=='X'))
                val-=1;
            else if(s.charAt(i)=='X'&&i!=s.length()-1&&(s.charAt(i+1)=='L'||s.charAt(i+1)=='C'))
                val-=10;
            else if(s.charAt(i)=='C'&&i!=s.length()-1&&(s.charAt(i+1)=='D'||s.charAt(i+1)=='M'))
                val-=100;
            else if(s.charAt(i)=='I')
                val+=1;
            else if(s.charAt(i)=='V')
                val+=5;
            else if(s.charAt(i)=='X')
                val+=10;
            else if(s.charAt(i)=='L')
                val+=50;
            else if(s.charAt(i)=='C')
                val+=100;
            else if(s.charAt(i)=='D')
                val+=500;
            else if(s.charAt(i)=='M')
                val+=1000;
        }
        return val;
    }
}


3. Longest Substring Without Repeating Characters
code:
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length()==1)
            return 1;
        String chk = "";
        String str1 = "";
        String str2 = "";
        for(int i=0;i<s.length();i++){
            for(int j=i;j<s.length();j++){
                chk = "";
                chk+=s.charAt(j);
                if(!(str1.contains(chk)))
                    str1+=s.charAt(j);
                else{
                    if(str1.length()>str2.length())
                        str2 = str1;
                    str1 = "";
                    break;
                }
            }
            // System.out.println(str1);
            // System.out.println(str2);
        }
        return str2.length();
    }
}


7. Reverse Integer
code:
import java.lang.Math;

class Solution {
    public int reverse(int x) {
        int flg=0;
        long rev = 0;
        if(x<0){
            x = Math.abs(x);
            flg=1;
        }
        
        while(x>0){
            rev = (rev*10) + (x%10);
            x/=10;
            // System.out.println(rev);
        }
        if(rev>2147483647)
            return 0;
        int rev1 = (int) rev;
        if(flg==1)
            rev1*=-1;
        return rev1;
    }
}


5. Longest Palindromic Substring
code:
//optimal
class Solution {
    public String expmid(String s,int left, int right){
        String ans = "";
        while(left>=0&&right<s.length()&&s.charAt(left)==s.charAt(right)){
            ans = "";
            // for(int i=left;i<=right;i++){
            //     ans = ans+s.charAt(i);
            // }
            ans = s.substring(left,right+1);
            // System.out.println(ans);
            left--;
            right++;
        }
        // System.out.println("ret = "+ans);
        return ans;
    }
    public String longestPalindrome(String s) {
        String s1,s2,ans="";
        for(int i=0;i<s.length();i++){
            s1 = expmid(s,i,i);
            s2 = expmid(s,i,i+1);
            if(s1.length()>=s2.length()&&s1.length()>ans.length())
                ans = s1;
            else if(s2.length()>=s1.length()&&s2.length()>ans.length())
                ans = s2;
        }
        return ans;
    }
}

//brute force:
class Solution {
    public String longestPalindrome(String s) {
        String str1 = "";
        String str2 = "";
        String chk_str="";
        for(int i=0;i<s.length();i++){
            str1="";
            str2="";
            for(int j=i;j<s.length();j++){
                str1+=s.charAt(j);
                str2 = "";
                for (int k = str1.length() - 1; k >= 0; k--) {
                    str2 = str2 + str1.charAt(k);
                }
                // System.out.println("str1="+str1);
                // System.out.println("str2="+str2);
                if(str1.equals(str2)&&str1.length()>chk_str.length())
                    chk_str = str1;
            }
        }
        return chk_str;
    }
}



334. Increasing Triplet Subsequence
code:
class Solution {
    public boolean increasingTriplet(int[] nums) {
        if(nums.length<3)
            return false;
        int a = Integer.MAX_VALUE,b = Integer.MAX_VALUE;
        for(int i=0;i<nums.length;i++){
            if(nums[i]<=a)
                a=nums[i];
            else if(nums[i]<=b)
                b=nums[i];
            else
                return true;
        }
        return false;
    }
}



20. Valid Parentheses
code:

import java.util.Stack;  
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stk= new Stack<>(); 
        for(int i=0;i<s.length();i++){
            if(stk.empty())
                stk.push(s.charAt(i));
            else if(s.charAt(i)==')'&&stk.peek()=='(')
                stk.pop();
            else if(s.charAt(i)==']'&&stk.peek()=='[')
                stk.pop();
            else if(s.charAt(i)=='}'&&stk.peek()=='{')
                stk.pop();
            else
                stk.push(s.charAt(i));
        }
        return stk.empty();
    }
}
// ([{}])


2095. Delete the Middle Node of a Linked List
code:
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteMiddle(ListNode head) {
        if(head.next==null)
            return null;
        ListNode fn = head,sn = head,temp=head;
        while(fn!=null&&fn.next!=null){
            fn=fn.next.next;
            temp = sn;
            sn=sn.next;
        }
        // System.out.println(temp.val);
        temp.next=sn.next;
        return head;
    }
}



692. Top K Frequent Words
code:
import java.util.Arrays; 
class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        List<String> l1 = new ArrayList<String>();
        int ind = -1;
        Arrays.sort(words); 
        // for (String string : words) 
        //     System.out.print(string + " "); 
        // System.out.println();
        
        int[] temp_arr = new int[words.length];
        int[] temp_arr2 = new int[words.length];
        int[] temp_arr3 = new int[words.length];
        
        for(int i=0;i<words.length;i++){
            for(int j=i+1;j<words.length;j++){
                if(words[i].equals(words[j])&&words[i]!="-0"){
                    temp_arr[i]++;
                    words[j] = "-0";
                }
            }
        }
        // for (String string : words) 
        //     System.out.print(string + " "); 
        // System.out.println();
        for(int i=0;i<temp_arr.length;i++){
            temp_arr2[i] = temp_arr[i];
        }
        // for(int i=0;i<temp_arr.length;i++){
        //     System.out.println(temp_arr[i]);
        // }
        Arrays.sort(temp_arr2);
        
        for(int i=temp_arr2.length-1;i>=0;i--){
            temp_arr3[temp_arr3.length-1-i] = temp_arr2[i];
        }
        System.out.println("temp_arr3");
        // for(int i=0;i<temp_arr.length;i++){
        //     System.out.println(temp_arr3[i]);
        // }
        for(int i=0;i<k;i++){
            // System.out.println("i = "+i);
            // ind = -1;
            for(int j=0;j<temp_arr.length;j++){
                if(temp_arr3[i]==temp_arr[j]&&temp_arr[j]!=-99&&words[j]!="-0"){
                    ind = j;
                    // System.out.println("ind = "+ind);
                    temp_arr[j] = -99;
                    break;
                }
            }
            l1.add(words[ind]);
        }
        
        
        
        return l1;
    }
}



11. Container With Most Water
code:
//brute force

import java.lang.Math;
class Solution {
    public int maxArea(int[] height) {
        int temp=0,themax=-1;
        for(int i=0;i<height.length;i++){
            for(int j=i+1;j<height.length;j++){
                temp = (j-i)*(Math.min(height[i],height[j]));
                if(temp>themax){
                    themax = temp;
                }
            }
        }
        return themax;
    }
}


//optimal

import java.lang.Math;
class Solution {
    public int maxArea(int[] height) {
        int i=0,j=height.length-1,area,res=0;
        while(i<j){
            area = (j-i)*(Math.min(height[i],height[j]));
            res = Math.max(res,area);
            if(height[i]<height[j])
                i++;
            else if(height[j]<height[i])
                j--;
            else
                j--;
        }
        return res;
    }
}


645. Set Mismatch
code:
class Solution {
    public int[] findErrorNums(int[] nums) {
        int[] arr = new int[nums.length+1];
        int[] ans = new int[2];
        for(int i=0;i<nums.length;i++){
            if(arr[nums[i]]!=0){
                ans[0] = nums[i];
            }
            arr[nums[i]]=1;
        }
        for(int i=1;i<arr.length;i++){
            if(arr[i]==0)
                ans[1] = i;
        }
        return ans;
    }
}



1662. Check If Two String Arrays are Equivalent
code:
class Solution {
    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {
        String w1 = "",w2 = "";
        for(int i=0;i<word1.length;i++){
            w1+=word1[i];
        }
        for(int i=0;i<word2.length;i++){
            w2+=word2[i];
        }
        if(w1.equals(w2))
            return true;
        return false;
    }
}

//time complexity O(n) and space complexity O(1)

class Solution {
    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {
        int arrind1 = 0, arrind2 = 0,id1=0,id2=0;
        while(arrind1<word1.length&&arrind2<word2.length){
            if(word1[arrind1].charAt(id1)!=word2[arrind2].charAt(id2)){
                return false;
            }
            id1++;
            id2++;
            if(id1==word1[arrind1].length()){
                arrind1++;
                id1=0;
            }
            if(id2==word2[arrind2].length()){
                arrind2++;
                id2=0;
            }
            
        }
        return arrind1==word1.length && arrind2==word2.length;
        
    }
}



15. 3Sum
//Brute Force approach:

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int sum;
        List<List<Integer>> lists = new ArrayList<>();
        List<Integer> li = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            for(int j=i+1;j<nums.length;j++){
                for(int k=j+1;k<nums.length;k++){
                    sum=nums[i]+nums[j]+nums[k];
                    if(sum==0){
                        li.add(nums[i]);
                        li.add(nums[j]);
                        li.add(nums[k]);
                        Collections.sort(li);
                        if(!lists.contains(li))
                            lists.add(li);
                        li = new ArrayList<>();
                    }
                }
            }
        }
        return lists;
    }
}


//Better Approach:

import java.util.*;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        HashSet<List<Integer>> new_set = new HashSet<>();
        int count;
        List<Integer> li = new ArrayList<>();
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(!map.containsKey(nums[i]))
                map.put(nums[i],1);
            else{
                count = map.get(nums[i]);
                count++;
                map.put(nums[i],count);
            }
        }
        for(int i=0;i<nums.length;i++){
            count = map.get(nums[i]);
            count--;
            map.put(nums[i],count);
            for(int j=i+1;j<nums.length;j++){
                count = map.get(nums[j]);
                count--;
                map.put(nums[j],count);
                // System.out.println(-1*(nums[i]+nums[j]));
                if((map.containsKey(-1*(nums[i]+nums[j])))&&(map.get(-1*(nums[i]+nums[j]))!=0)){
                    li = new ArrayList<>();
                    li.add(nums[i]);
                    li.add(nums[j]);
                    li.add(-1*(nums[i]+nums[j]));
                    Collections.sort(li);
                    new_set.add(li);
                    // System.out.println(li);
                    
                    // lists.add(li);
                }
                count = map.get(nums[j]);
                count++;
                map.put(nums[j],count);
            }
            count = map.get(nums[i]);
            count++;
            map.put(nums[i],count);
        }
        
        List<List<Integer>> lists = new ArrayList<>(new_set);
        return lists;
    }
}




1323. Maximum 69 Number

class Solution {
    public int maximum69Number (int num) {
        int[] arr = new int[100000];
        int[] arr2 = new int[100000];
        int x = num,i=0,k=0,temp=0;
        while(x>0){
            arr[i] = x%10;
            x/=10;
            i++;
        }
        // System.out.println(i);
        for(int j=i-1;j>=0;j--){
            arr2[k] = arr[j];
            k++;
        }
        for(int j=0;j<i;j++){
            temp=0;
            if(arr2[j]==6){
                arr2[j]=9;
                for(k=0;k<i;k++){
                    temp=(temp*10)+arr2[k];
                }
                if(temp>num)
                    num = temp;
                arr2[j] = 6;
            }
            
            
        }
        
        
        return num;
    }
}



1544. Make The String Great

class Solution {
    public int chkbad(String s){
        int flg = 0;
        for(int i=1;i<s.length();i++){
            if(((Character.toUpperCase(s.charAt(i-1))==s.charAt(i))||(Character.toUpperCase(s.charAt(i))==s.charAt(i-1)))&&((s.charAt(i-1))!=s.charAt(i))){
                flg = 1;
                System.out.println(i+" "+(i-1));
            }
        }
        return flg;
    }
    public String makeGood(String s) {
                if(s.length()==2){
            if((Character.toUpperCase(s.charAt(0))==s.charAt(1))||(Character.toUpperCase(s.charAt(1))==s.charAt(0))){
                return "";
            }
        }
        if(s.equals(""))
            return "";
        int flg;
        flg = chkbad(s);
        while(flg==1){
            System.out.println(flg);
        for(int i=1;i<s.length();i++){
            if(((Character.toUpperCase(s.charAt(i-1))==s.charAt(i))||(Character.toUpperCase(s.charAt(i))==s.charAt(i-1)))&&((s.charAt(i-1))!=s.charAt(i))){
                s = s.substring(0,i-1)+s.substring(i+1,s.length());
                // System.out.println("a");
            }
        }
                    if(s.length()==2){
            if((Character.toUpperCase(s.charAt(0))==s.charAt(1))||(Character.toUpperCase(s.charAt(1))==s.charAt(0))&&((s.charAt(0))!=s.charAt(1))){
                return "";
            }
        }
            System.out.println(s);
            flg = chkbad(s);
            // System.out.println(flg);
    }
        return s;
    }
}




222. Count Complete Tree Nodes

code:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int cou = 1;
    public void trav(TreeNode root){
        // System.out.println(root.val);
        cou++;
        if(root!=null&&root.left!=null)
            trav(root.left);
        if(root!=null&&root.right!=null)
            trav(root.right);
        if(root!=null&&root.left==null&&root.right==null)
            return;
    }
    public int countNodes(TreeNode root) {
        if(root==null)
            return 0;
        if(root.left==null&&root.right==null)
            return cou;
        if(root!=null&&root.left!=null)
            trav(root.left);
        if(root!=null&&root.right!=null)
            trav(root.right);
        
        return cou;
    }
}



1047. Remove All Adjacent Duplicates In String
code:
class Solution {
    public String removeDuplicates(String s) {
        String str = "";
        char arr[] = new char[s.length()+1];
        int i = 0;
        for(int j=0;j<s.length();j++){
            arr[j] = '0';
        }
        for(int j = 0;j<s.length();j++){
            if(s.charAt(j)!=arr[i]){
                i++;
                // System.out.println(arr[i]+" "+s.charAt(j));
                arr[i] = s.charAt(j);
            }
            else if(s.charAt(j)==arr[i]){
                i--;
            }
        }
        for(int j=1;j<=i;j++){
            if(arr[j]!='0')
                str+=arr[j];
        }
        return str;
    }
}



1704. Determine if String Halves Are Alike

class Solution {
    public boolean halvesAreAlike(String s) {
        int mid = s.length()/2;
        int l=0,r=0;
        char ch1,ch2;
        for(int i=0;i<mid;i++){
            ch1 = s.charAt(i);
            ch2 = s.charAt(mid+i);
            if(ch1=='a'||ch1=='e'||ch1=='i'||ch1=='o'||ch1=='u'||ch1=='A'||ch1=='E'||ch1=='I'||ch1=='O'||ch1=='U'){
                l++;
            }
            if(ch2=='a'||ch2=='e'||ch2=='i'||ch2=='o'||ch2=='u'||ch2=='A'||ch2=='E'||ch2=='I'||ch2=='O'||ch2=='U'){
                r++;
            }
        }
        if(l==r)
            return true;
        return false;
    }
}


1207. Unique Number of Occurrences

import java.util.*;

class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int t = 0,count,count1=0;
        for(int i=0;i<arr.length;i++){
            if(!map.containsKey(arr[i])){
                map.put(arr[i],1);
            }
            else{
                t = map.get(arr[i]);
                t++;
                map.put(arr[i],t);
            }
        }
        for (Map.Entry<Integer, Integer> e : map.entrySet())
            count1++;
        count = (int)map.values().stream().distinct().count();
        
        if(count1==count)
            return true;
        return false;
    }
}


328. Odd Even Linked List

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode oddEvenList(ListNode head) {
        ListNode hp = head;
        int size = 0,tr=1,fo=0,fe,noe;
        while(hp!=null){
            size++;
            hp=hp.next;
        }
        noe = (int)Math.floor(size/2);
        fe = size-noe;
        // System.out.println(size);
        int[] arr = new int[size];
        hp = head;
        while(hp!=null){
            if(tr%2!=0){
                arr[fo] = hp.val;
                fo++;
            }
            else{
                arr[fe] = hp.val;
                fe++;
            }
            tr++;
            hp=hp.next;
        }
        hp = head;
        for(int i=0;i<arr.length;i++){
            hp.val = arr[i];
            hp=hp.next;
        }


        return head;
    }
}
